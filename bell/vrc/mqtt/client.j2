# This file is automatically generated. DO NOT EDIT!
# fmt: off

from __future__ import annotations

import copy
import json
from typing import Any, Literal, Optional, TypedDict, Union, overload

import paho.mqtt.client as mqtt
from loguru import logger

from .payloads import (
{%- for topic in topics %}
    {{ topic.name }}Payload,
    _{{ topic.name }}Callable,
{%- endfor %}
)
from ..utils.decorators import try_except


# create typed dict of topics associated with callbacks
_MQTTTopicCallable = TypedDict(
    "_MQTTTopicCallable",
    {
{%- for topic in topics %}
        "{{ topic.path }}": _{{ topic.name }}Callable,
{%- endfor %}
    },
    total=False
)

# create typed dict of topics associated with payloads
_MQTTTopicPayload = TypedDict(
    "_MQTTTopicPayload",
    {
{%- for topic in topics %}
        "{{ topic.path }}": {{ topic.name }}Payload,
{%- endfor %}
    },
    total=False
)


class MQTTModule:
    """
    Generic MQTT Module class that should be inherited by other modules.
    The `topic_map` attribute should be a dictionary of topics to functions
    that will be called with a payload.
    """

    def __init__(self):
        # these should be not be changed
        self.mqtt_host = "mqtt"
        self.mqtt_port = 18830

        # create the MQTT client
        self._mqtt_client = mqtt.Client()

        # set up the on connect and on message handlers
        self._mqtt_client.on_connect = self.on_connect
        self._mqtt_client.on_message = self.on_message

        # dictionary of MQTT topics to callback functions
        # this is intended to be overwritten by the child class
        self.topic_map: _MQTTTopicCallable = {}

        # maintain a cache of the last message sent on a topic by this module
        self.message_cache: _MQTTTopicPayload = {}

    def run(self) -> None:
        """
        Class entrypoint. Connects to the MQTT broker and starts the MQTT loop
        in a blocking manner.
        """
        # connect the MQTT client
        self._mqtt_client.connect(host=self.mqtt_host, port=self.mqtt_port, keepalive=60)
        # run forever
        self._mqtt_client.loop_forever()

    def run_non_blocking(self) -> None:
        """
        Class entrypoint. Connects to the MQTT broker and starts the MQTT loop
        in a non-blocking manner.
        """
        # connect the MQTT client
        self._mqtt_client.connect(host=self.mqtt_host, port=self.mqtt_port, keepalive=60)
        # run in background
        self._mqtt_client.loop_start()

    @try_except()
    def on_message(
        self, client: mqtt.Client, userdata: Any, msg: mqtt.MQTTMessage
    ) -> None:
        """
        On message callback, dispatches the message to the appropriate function.
        """
        # logger.debug(f"Recieved {msg.topic}: {msg.payload}")
        if msg.topic in self.topic_map:
            # we talk JSON, no exceptions
            payload = json.loads(msg.payload)
            self.topic_map[msg.topic](payload)

    def on_connect(
        self,
        client: mqtt.Client,
        userdata: Any,
        rc: Any,
        properties: Optional[mqtt.Properties] = None,
    ) -> None:
        """
        On connection callback. Subscribes to MQTT topics in the topic map.
        """
        logger.debug(f"Connected with result {rc}")

        for topic in self.topic_map.keys():
            client.subscribe(topic)
            logger.success(f"Subscribed to: {topic}")

{%- for topic in topics %}

    @overload
    def send_message(self, topic: Literal["{{ topic.path }}"], payload: {{ topic.name }}Payload) -> None: ...
{%- endfor %}

    def send_message(self, topic: Literal[{% for topic in topics %}"{{ topic.path }}"{% if not loop.last %},{% endif %} {% endfor %}], payload: Union[{% for topic in topics %}{{ topic.name }}Payload{% if not loop.last %},{% endif %} {% endfor %}]) -> None:
        """
        Sends a message to the MQTT broker.
        """
        # logger.debug(f"Sending message to {topic}: {payload}")
        self._mqtt_client.publish(topic, json.dumps(payload))
        self.message_cache[topic] = copy.deepcopy(payload)

