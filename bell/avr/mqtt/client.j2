# This file is automatically @generated. DO NOT EDIT!
# fmt: off

from __future__ import annotations

import copy
import json
import uuid
from typing import Any, Literal, Union, overload

import paho.mqtt.client as mqtt
from loguru import logger
import pydantic

from .constants import _MQTTTopicCallableTypedDict, _MQTTTopicPayloadTypedDict, MQTTTopicPayload
from .payloads import (
{%- for topic, klass in topic_class.items() %}
    {{ klass }},
{%- endfor %}
)
from ..utils.decorators import try_except


class MQTTModule:
    """
    Generic MQTT Module class that should be inherited by other modules.
    The `topic_map` attribute should be a dictionary of topics to functions
    that will be called with a payload.
    """

    def __init__(self):
        # these should be not be changed
        self.mqtt_host = "mqtt"
        self.mqtt_port = 18830

        # create the MQTT client
        # Currently using MQTT v3.1.1
        # No reason we can't use v5, just type hinting needs to change
        # for some `on_` functions.
        self._mqtt_client = mqtt.Client(client_id=f"{self.__class__.__name__}_{uuid.UUID4().to_hex()}", protocol=mqtt.MQTTv311)

        # set up the on connect and on message handlers
        self._mqtt_client.on_connect = self.on_connect
        self._mqtt_client.on_message = self.on_message

        # dictionary of MQTT topics to callback functions
        # this is intended to be overwritten by the child class
        self.topic_map: _MQTTTopicCallableTypedDict = {}

        # maintain a cache of the last message sent on a topic by this module
        self.message_cache: _MQTTTopicPayloadTypedDict = {}

        # record if we were started with loop forever
        self._looped_forever = False

    def run(self) -> None:
        """
        Class entrypoint. Connects to the MQTT broker and starts the MQTT loop
        in a blocking manner.
        """
        # connect the MQTT client
        self._mqtt_client.connect(host=self.mqtt_host, port=self.mqtt_port, keepalive=60)
        # run forever
        self._looped_forever = True
        self._mqtt_client.loop_forever()

    def run_non_blocking(self) -> None:
        """
        Class entrypoint. Connects to the MQTT broker and starts the MQTT loop
        in a non-blocking manner.
        """
        # connect the MQTT client
        self._mqtt_client.connect(host=self.mqtt_host, port=self.mqtt_port, keepalive=60)
        # run in background
        self._mqtt_client.loop_start()

    @try_except()
    def on_message(self, client: mqtt.Client, userdata: Any, msg: mqtt.MQTTMessage) -> None:
        """
        On message callback, dispatches the message to the appropriate function.
        """
        # logger.debug(f"Recieved {msg.topic}: {msg.payload}")
        if msg.topic in self.topic_map:
            # we talk JSON, no exceptions
            payload = json.loads(msg.payload)

            # load the json into a pydantic model
            klass = MQTTTopicPayload[msg.topic](**payload)

            # execute callback
            self.topic_map[msg.topic](klass)

    def on_connect(self, client: mqtt.Client, userdata: Any, flags: dict, rc: int) -> None:
        """
        On connection callback. Subscribes to MQTT topics in the topic map.
        """
        logger.debug(f"Connected with result {rc}")

        for topic in self.topic_map.keys():
            client.subscribe(topic)
            logger.success(f"Subscribed to: {topic}")

{%- for topic, klass in topic_class.items() %}
    @overload
    def send_message(self, topic: Literal["{{ topic }}"], payload: Union[{{ klass }}, dict{%- if klass == "AVREmptyMessage" -%}, None{%- endif -%}], force_write: bool) -> None: ...
{%- endfor %}

    def send_message(self, topic: str, payload: Union[pydantic.BaseModel, dict, None] = None, force_write: bool = False) -> None:
        """
        Sends a message to the MQTT broker. Enabling `force_write` will
        forcefully send the message, bypassing threading mutex. Only use this
        if you know what you're doing.
        """
        # logger.debug(f"Sending message to {topic}: {payload}")

        # if no payload given, use empty dict
        if payload is None:
            payload = {}

        str_payload = ""

        # if a dict is provided, convert to a pydantic class
        if isinstance(payload, dict):
            if topic not in MQTTTopicPayload:
                # if topic is not known, pass it on as JSON
                str_payload = json.dumps(payload)
            else:
                payload = MQTTTopicPayload[topic](**payload)

        # if we have a pydantic class by now, convert to JSON
        if isinstance(payload, pydantic.BaseModel):
            str_payload = payload.json()

        self._mqtt_client.publish(topic, str_payload)

        # https://github.com/eclipse/paho.mqtt.python/blob/9782ab81fe7ee3a05e74c7f3e1d03d5611ea4be4/src/paho/mqtt/client.py#L1563
        # pre-emptively write network data while still in a callback, bypassing
        # the thread mutex.
        # can only be used if run with .loop_forever()
        # https://www.bellavrforum.org/t/sending-messages-to-pcc-from-sandbox/311/8
        if self._looped_forever or force_write:
            self._mqtt_client.loop_write()

        self.message_cache[topic] = copy.deepcopy(payload)
