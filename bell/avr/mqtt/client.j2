# This file is automatically @generated. DO NOT EDIT!
# fmt: off

from __future__ import annotations

import copy
import json
import os
import uuid
from typing import Any, Literal, Union, overload

import paho.mqtt.client as mqtt
from loguru import logger
import pydantic

from bell.avr.mqtt.constants import _MQTTTopicCallableTypedDict, _MQTTTopicPayloadTypedDict, MQTTTopicPayload
from bell.avr.mqtt.payloads import (
{%- for klass in topic_class.values()|unique %}
    {{ klass }},
{%- endfor %}
)
from bell.avr.utils.env import get_env_int


class MQTTModule:
    """
    Generic MQTT Module class that should be inherited by other modules.
    The `topic_map` attribute should be a dictionary of topics to functions
    that will be called with a payload.
    """

    def __init__(self):
        self.mqtt_host = os.getenv("MQTT_HOST", "mqtt")
        self.mqtt_port = get_env_int("MQTT_PORT", 18830)

        # create the MQTT client
        # Currently using MQTT v3.1.1
        # No reason we can't use v5, just type hinting needs to change
        # for some `on_` functions.
        self._mqtt_client = mqtt.Client(client_id=f"{self.__class__.__name__}_{uuid.uuid4()}", protocol=mqtt.MQTTv311)

        # set up the on connect and on message handlers
        self._mqtt_client.on_connect = self.on_connect
        self._mqtt_client.on_message = self.on_message

        # dictionary of MQTT topics to callback functions
        # this is intended to be overwritten by the child class
        self.topic_map: _MQTTTopicCallableTypedDict = {}

        # flag to subscribe to all topics on connect
        self.subscribe_to_all_topics: bool = False

        # maintain a cache of the last message sent on a topic by this module
        self.message_cache: _MQTTTopicPayloadTypedDict = {}

        # record if we were started with loop forever
        self._looped_forever = False

    def run(self) -> None:
        """
        Class entrypoint. Connects to the MQTT broker and starts the MQTT loop
        in a blocking manner.
        """
        # connect the MQTT client
        self._mqtt_client.connect(host=self.mqtt_host, port=self.mqtt_port, keepalive=60)
        # run forever
        self._looped_forever = True
        self._mqtt_client.loop_forever()

    def run_non_blocking(self) -> None:
        """
        Class entrypoint. Connects to the MQTT broker and starts the MQTT loop
        in a non-blocking manner.
        """
        # connect the MQTT client
        self._mqtt_client.connect(host=self.mqtt_host, port=self.mqtt_port, keepalive=60)
        # run in background
        self._mqtt_client.loop_start()

    def stop(self) -> None:
        """
        Stops the MQTT loop and disconnects from the broker. Can only be used with
        `run_non_blocking`.
        """
        self._mqtt_client.loop_stop()

    def on_message(self, client: mqtt.Client, userdata: Any, msg: mqtt.MQTTMessage) -> None:
        """
        On message callback, dispatches the message to the appropriate function.
        """
        # logger.debug(f"Recieved {msg.topic}: {msg.payload}")
        if msg.topic not in self.topic_map:
            return

        # so json.loads doesn't choke on an empty string
        if not msg.payload:
            msg.payload = b"{}"

        # we talk JSON, no exceptions
        payload = json.loads(msg.payload)

        # load the json into a pydantic model
        if msg.topic in MQTTTopicPayload:
            klass = MQTTTopicPayload[msg.topic](**payload)

        # if we have an empty dict, manually convert it
        elif payload == {}:
            klass = AVREmptyMessage()

        # whatever the user gave us
        else:
            klass = payload

        # execute callback
        if isinstance(klass, AVREmptyMessage):
            self.topic_map[msg.topic]()
        else:
            self.topic_map[msg.topic](klass)

    def on_connect(self, client: mqtt.Client, userdata: Any, flags: dict, rc: int) -> None:
        """
        On connection callback. Subscribes to MQTT topics in the topic map.
        """
        logger.debug(f"Connected with result {rc}")

        for topic in self.topic_map.keys():
            client.subscribe(topic)
            logger.success(f"Subscribed to: {topic}")

        if self.subscribe_to_all_topics:
            client.subscribe("avr/#")
            logger.success("Subscribed to: avr/#")
{% for topic, klass in topic_class.items() %}
    @overload
    def send_message(self, topic: Literal["{{ topic }}"], payload: Union[{{ klass }}, dict{%- if klass == "AVREmptyMessage" -%}, None] = None{%- else -%}]{%- endif -%}, force_write: bool = False) -> None: ...
{%- endfor %}

    def send_message(self, topic: str, payload: Union[pydantic.BaseModel, dict, None] = None, force_write: bool = False) -> None:
        """
        Sends a message to the MQTT broker. Enabling `force_write` will
        forcefully send the message, bypassing threading mutex. Only use this
        if you know what you're doing.
        """
        # logger.debug(f"Sending message to {topic}: {payload}")

        # if no payload given, use empty message
        if payload is None:
            payload = AVREmptyMessage()

        # if payload is for a known topic, convert to pydantic model
        if topic in MQTTTopicPayload and not isinstance(
            payload, pydantic.BaseModel
        ):
            payload = MQTTTopicPayload[topic](**payload)

        # convert pydantic models to json
        if isinstance(payload, pydantic.BaseModel):
            str_payload = payload.json()
        # convert any other data type to json
        else:
            str_payload = json.dumps(payload)

        self._mqtt_client.publish(topic, str_payload)

        # https://github.com/eclipse/paho.mqtt.python/blob/9782ab81fe7ee3a05e74c7f3e1d03d5611ea4be4/src/paho/mqtt/client.py#L1563
        # pre-emptively write network data while still in a callback, bypassing
        # the thread mutex.
        # can only be used if run with .loop_forever()
        # https://www.bellavrforum.org/t/sending-messages-to-pcc-from-sandbox/311/8
        if self._looped_forever or force_write:
            self._mqtt_client.loop_write()

        self.message_cache[topic] = copy.deepcopy(payload)
